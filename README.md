# Spo Lab 1
Задание 1
Использовать средство синтаксического анализа по выбору, реализовать модуль для разбора текста в
соответствии с языком по варианту. Реализовать построение по исходному файлу с текстом синтаксического
дерева с узлами, соответствующими элементам синтаксической модели языка. Вывести полученное дерево в
файл в формате, поддерживающем просмотр графического представления.
Порядок выполнения:
1 Изучить выбранное средство синтаксического анализа
a. Средство должно поддерживать программный интерфейс, совместимый с языком Си
b. Средство должно параметризоваться спецификацией, описывающей синтаксическую структуру
разбираемого языка
c.
Средство может функционировать посредством кодогенерации и/или подключения
необходимых для его работы дополнительных библиотек
d. Средство может быть реализовано с нуля, в этом случае оно должно использовать
обобщённый алгоритм, управляемый спецификацией
2 Изучить синтаксис разбираемого по варианту языка и записать спецификацию для средства
синтаксического анализа, включающую следующие конструкции:
a. Подпрограммы со списком аргументов и возвращаемым значением
b. Операции контроля потока управления – простые ветвления if-else и циклы или аналоги
c.
В зависимости от варианта – определения переменных
d. Целочисленные, строковые и односимвольные литералы
e. Выражения численной, битовой и логической арифметики
f.
Выражения над одномерными массивами
g.
Выражения вызова функции
3 Реализовать модуль, использующий средство синтаксического анализа для разбора языка по варианту
a. Программный интерфейс модуля должен принимать строку с текстом и возвращать структуру,
описывающую соответствующее дерево разбора и коллекцию сообщений ошибке
b. Результат работы модуля – дерево разбора – должно содержать иерархическое
представление для всех синтаксических конструкций, включая выражения, логически
представляющие собой иерархически организованные данные, даже если на уровне средства
синтаксического анализа для их разбора было использовано линейное представление
4 Реализовать тестовую программу для демонстрации работоспособности созданного модуля
a. Через аргументы командной строки программа должна принимать имя входного файла для
чтения и анализа, имя выходного файла записи для дерева, описывающего синтаксическую
структуру разобранного текста
b. Сообщения об ошибке должны выводиться тестовой программной (не модулем, отвечающим
за анализ!) в стандартный поток вывода ошибок
5 Результаты тестирования представить в виде отчета, в который включить:
a. В части 3 привести описание структур данных, представляющих результат разбора текста (3а)
b. В части 4 описать, какая дополнительная обработка потребовалась для результата разбора,
предоставляемого средством синтаксического анализа, чтобы сформировать результат работы
созданного модуля
c.
В части 5 привести примеры исходных анализируемых текстов для всех синтаксических
конструкций разбираемого языка и соответствующие результаты разбора


Общая часть синтаксической модели для всех вариантов:
identifier: "[a-zA-Z_][a-zA-Z_0-9]*"; // идентификатор
str: "\"[^\"\\]*(?:\\.[^\"\\]*)*\""; // строка, окруженная двойными кавычками
char: "'[^']'";
// одиночный символ в одинарных кавычках
hex: "0[xX][0-9A-Fa-f]+";
// шестнадцатеричный литерал
bits: "0[bB][01]+";
// битовый литерал
dec: "[0-9]+";
// десятичный литерал
bool: 'true'|'false';
// булевский литерал
list<item>: (item (',' item)*)?; // список элементов, разделённых запятыми

source: sourceItem*;
typeRef: {
|builtin: 'bool'|'byte'|'int'|'uint'|'long'|'ulong'|'char'|'string';
|custom: identifier;
|array: typeRef '[' (',')* ']';
};
funcSignature: typeRef? identifier '(' list<argDef> ')' {
argDef: typeRef? identifier;
};
sourceItem: {
|funcDef: funcSignature (statement.block|';');
};
statement: {
|var: typeRef list<identifier ('=' expr)?> ';'; // for static typing
|if: 'if' '(' expr ')' statement ('else' statement)?;
|block: '{' statement* '}';
|while: 'while' '(' expr ')' statement;
|do: 'do' block 'while' '(' expr ')' ';';
|break: 'break' ';';
|expression: expr ';'
};
expr: { // присваивание через '='
|binary: expr binOp expr; // где binOp - символ бинарного оператора
|unary: unOp expr; // где unOp - символ унарного оператора
|braces: '(' expr ')';
|call: expr '(' list<expr> ')';
|indexer: expr '[' list<expr> ']';
|place: identifier;
|literal: bool|str|char|hex|bits|dec;
};
